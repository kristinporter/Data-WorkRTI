<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Session 3</title>
    <meta charset="utf-8" />
    <meta name="author" content="Kristin Porter" />
    <meta name="date" content="2024-05-25" />
    <script src="Session3_Part3TidyverseRevewAndExpansions_files/header-attrs-2.26/header-attrs.js"></script>
    <link href="Session3_Part3TidyverseRevewAndExpansions_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="Session3_Part3TidyverseRevewAndExpansions_files/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link href="Session3_Part3TidyverseRevewAndExpansions_files/panelset-0.3.0/panelset.css" rel="stylesheet" />
    <script src="Session3_Part3TidyverseRevewAndExpansions_files/panelset-0.3.0/panelset.js"></script>
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Session 3
]
.author[
### Kristin Porter
]
.date[
### 2024-05-25
]

---



&lt;!-- Add CSS in a style block --&gt;
&lt;style&gt;
.two-columns {
  display: flex;
}
.column {
  flex: 1;
  padding: 10px;
}
&lt;/style&gt;

&lt;style&gt;
  .centered {
    display: flex;
    justify-content: center; /* Horizontal centering */
    align-items: center;    /* Vertical centering */
    height: 100vh;         /* Full height of the viewport */
  }
&lt;/style&gt;



---
## Taking stock

**`tidyverse`**: a collection of R packages designed around a set of data structures that make it easier to manipulate, analyze and visualize data consisently and predictably. 

&lt;div class="two-columns"&gt;
  &lt;div class="column"&gt;
    &lt;!-- First column  --&gt;

#### Session 1: 
- list of `tidyverse` packages
- reading in &amp; writing out data with `tidyverse` functions
- manipulating &amp; summarizing data with `dplyr`

#### Session 2: 
- statistical summaries with `dplyr` (&amp; base R)
- data visualization with `ggplot2` (&amp; base R)
  &lt;/div&gt;
  &lt;div class="column"&gt;
    &lt;!-- Second column --&gt;
#### Session 3: 
- Review of manipulating &amp; summarizing data with `dplyr`
- Expanding this with `purrr` (with similarities to `apply()` from Session 2)
- Practice &amp; questions

#### Session 4: (if time)
- Review of `ggplot2` for data viz
- Intro to `gt` for tables
- More practice &amp; questions w/ exercise
  &lt;/div&gt;
&lt;/div&gt;
```
```
```
---
&lt;div class="centered"&gt;
  &lt;h1&gt;dplyr&lt;/h1&gt;
&lt;/div&gt;

---
## Introduction to dplyr?

### Why dplyr?
-   Simplified syntax.
-   Fast and consistent performance.
-   Integrates well with other Tidyverse packages.

### Working with tibbles

Tibbles are a modern take on data frames, but they are tweaked to work better with the Tidyverse. Converting a data frame to a tibble is straightforward:

---


```r
library(dplyr)
# creating toy data frame
my_data_frame &lt;- data.frame(x = c(3,2,2,4,1,1), y = c("c","b","d","d","a","a"),
                            z = c(TRUE,FALSE,TRUE,FALSE,TRUE,TRUE))
# converting data frame to a tibble &amp; printing
my_tibble &lt;- as_tibble(my_data_frame)
my_tibble
```

```
## # A tibble: 6 × 3
##       x y     z    
##   &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt;
## 1     3 c     TRUE 
## 2     2 b     FALSE
## 3     2 d     TRUE 
## 4     4 d     FALSE
## 5     1 a     TRUE 
## 6     1 a     TRUE
```

```r
# glimpe of tibble
glimpse(my_tibble) #like str()
```

```
## Rows: 6
## Columns: 3
## $ x &lt;dbl&gt; 3, 2, 2, 4, 1, 1
## $ y &lt;chr&gt; "c", "b", "d", "d", "a", "a"
## $ z &lt;lgl&gt; TRUE, FALSE, TRUE, FALSE, TRUE, TRUE
```

---
## Basic dplyr functions

The `dplyr` package has a wide range of functions (or "verbs") for manipulating tibbles in a user-friendly way.

See this online resource[https://dplyr.tidyverse.org/reference/index.html] for a helpful list.

---
## Operations on ROWS: filter()

Filters rows based on a condition.


```r
filtered_data &lt;- filter(my_tibble, x &gt; 2)
filtered_data
```

```
## # A tibble: 2 × 3
##       x y     z    
##   &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt;
## 1     3 c     TRUE 
## 2     4 d     FALSE
```
---
## Operations on ROWS: arrange()

Reorders rows.


```r
arranged_data &lt;- arrange(my_tibble, desc(x))
arranged_data
```

```
## # A tibble: 6 × 3
##       x y     z    
##   &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt;
## 1     4 d     FALSE
## 2     3 c     TRUE 
## 3     2 b     FALSE
## 4     2 d     TRUE 
## 5     1 a     TRUE 
## 6     1 a     TRUE
```

---
## Operations on ROWS: distinct()

Keeps unique/distinct rows.

&lt;div class="two-columns"&gt;
  &lt;div class="column"&gt;
    &lt;!-- First column --&gt;

```r
# remove rows that are
# duplicate across all columns
distinct_data &lt;- distinct(my_tibble)
distinct_data
```

```
## # A tibble: 5 × 3
##       x y     z    
##   &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt;
## 1     3 c     TRUE 
## 2     2 b     FALSE
## 3     2 d     TRUE 
## 4     4 d     FALSE
## 5     1 a     TRUE
```
  &lt;/div&gt;
  &lt;div class="column"&gt;
    &lt;!-- Second column --&gt;

```r
# remove duplicates of x
# keeping first row if different
distinct_x &lt;- distinct(my_tibble,
              x, .keep_all = TRUE)
distinct_x
```

```
## # A tibble: 4 × 3
##       x y     z    
##   &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt;
## 1     3 c     TRUE 
## 2     2 b     FALSE
## 3     4 d     FALSE
## 4     1 a     TRUE
```
  &lt;/div&gt;
&lt;/div&gt;
```
```
```

---
## Operations on ROWS: slice()

Extract specific rows. (As a reminder, use `Help` is helpful!)


```r
# get rows 1, 2 and 3
sliced_data1 &lt;- slice(my_tibble,c(1,2,3))
sliced_data1
```

```
## # A tibble: 3 × 3
##       x y     z    
##   &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt;
## 1     3 c     TRUE 
## 2     2 b     FALSE
## 3     2 d     TRUE
```

```r
# get rows with 2 top maximum values of a variable
sliced_data2 &lt;- slice_max(my_tibble,x,n=2)
sliced_data2 
```

```
## # A tibble: 2 × 3
##       x y     z    
##   &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt;
## 1     4 d     FALSE
## 2     3 c     TRUE
```


---
## Operations on COLUMNS: select()

Selects columns from a dataset.


```r
selected_data &lt;- select(my_tibble, x, y)
selected_data
```

```
## # A tibble: 6 × 2
##       x y    
##   &lt;dbl&gt; &lt;chr&gt;
## 1     3 c    
## 2     2 b    
## 3     2 d    
## 4     4 d    
## 5     1 a    
## 6     1 a
```

---
## Operations on COLUMNS: mutate()

Adds new columns or transforms existing ones.


```r
mutated_data &lt;- mutate(my_tibble, w = x * 2)
mutated_data
```

```
## # A tibble: 6 × 4
##       x y     z         w
##   &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; &lt;dbl&gt;
## 1     3 c     TRUE      6
## 2     2 b     FALSE     4
## 3     2 d     TRUE      4
## 4     4 d     FALSE     8
## 5     1 a     TRUE      2
## 6     1 a     TRUE      2
```

---
## Piping

We can carry out numerous operations/manipulations on rows and columns at a time with the following format. We create a new tibble, assign it to the tibble we want to revise followed by %\&gt;%. Then we can call multiple dplyr functions/verbs in a slightly different format. Mainly, we no longer pass in the tibble to each function since we have already noted it. And, following each function/verb, we add another %\&gt;% - to the end of all except the final function.


```r
new_data &lt;- my_tibble %&gt;%
  filter(z) %&gt;%               # Filter rows where z is TRUE
  select(x, y) %&gt;%            # Select columns x and y
  mutate(double_x = x * 2)    # Create a new column 'double_x' which is twice the value of x

new_data
```

```
## # A tibble: 4 × 3
##       x y     double_x
##   &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;
## 1     3 c            6
## 2     2 d            4
## 3     1 a            2
## 4     1 a            2
```

&lt;!-- ### Operations on GROUPS of ROWS --&gt;

&lt;!-- #### summarize --&gt;

&lt;!-- Compute summary statistics across rows (observations) for designated columns. --&gt;

&lt;!-- ```{r summarizeData} --&gt;
&lt;!-- # compute the mean of x across all observations --&gt;
&lt;!-- summarized_x &lt;- summarize(my_tibble,mean_x=mean(x)) --&gt;
&lt;!-- summarized_x --&gt;

&lt;!-- # we can also compute multiple summary statistics at one time: --&gt;
&lt;!-- summary_stats &lt;- my_tibble %&gt;% --&gt;
&lt;!--   summarize( --&gt;
&lt;!--     mean_x = mean(x), --&gt;
&lt;!--     median_x = median(x), --&gt;
&lt;!--     max_x = max(x) --&gt;
&lt;!--   ) --&gt;
&lt;!-- summary_stats --&gt;
&lt;!-- ``` --&gt;

&lt;!-- #### group_by --&gt;

&lt;!-- Takes an existing tibble and converts it into a grouped tibble where operations are performed "by group." --&gt;

&lt;!-- ```{r groupData} --&gt;
&lt;!-- # just grouping data - by whether z is TRUE OR FALSE --&gt;
&lt;!-- grouped_data &lt;- group_by(my_tibble,z) --&gt;

&lt;!-- # if we print our data, it looks the same, but it tells us it is grouped and how --&gt;
&lt;!-- grouped_data --&gt;

&lt;!-- # now if we run another dplyr function, it will take the grouping into account --&gt;
&lt;!-- grouped_data_means &lt;- summarize(grouped_data,mean_x=mean(x)) --&gt;
&lt;!-- grouped_data_means # note that this object is another tibble! abbreviated as tbl --&gt;

&lt;!-- # we can combine things here... --&gt;
&lt;!-- summary_stats &lt;- my_tibble %&gt;% --&gt;
&lt;!--     group_by(z) %&gt;% --&gt;
&lt;!--     summarize( --&gt;
&lt;!--     mean_x = mean(x), --&gt;
&lt;!--     median_x = median(x), --&gt;
&lt;!--     max_x = max(x) --&gt;
&lt;!--   ) --&gt;
&lt;!-- summary_stats --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Here is another example of using group_by with another row operation - arrange. In this case, the sorting will happen within groups defined by whether z is TRUE or FALSE. Note it does not sort by groups in the results. But this could be accomplished with another call to arrange(). --&gt;

&lt;!-- ```{r arrangeGroupedData} --&gt;
&lt;!-- # adding a variable for illustration --&gt;
&lt;!-- my_tibble_addw &lt;- mutate(my_tibble, w = c(3,2,-4,0,1)) --&gt;
&lt;!-- my_tibble_addw --&gt;
&lt;!-- # arranging tbl by descending order of w, by group defined by z --&gt;
&lt;!-- arranged_grouped_data &lt;- my_tibble_addw %&gt;% --&gt;
&lt;!--     group_by(z) %&gt;% --&gt;
&lt;!--     arrange(desc(w)) --&gt;
&lt;!-- arranged_grouped_data --&gt;
&lt;!-- ``` --&gt;

&lt;!-- ### Operations on GROUPS of COLUMNS --&gt;

&lt;!-- #### across --&gt;

&lt;!-- Apply functions across multiple columns. It's particularly useful in conjunction with mutate() and summarize() functions. across() allows you to perform the same operation on multiple columns without having to write repetitive code for each column. --&gt;

&lt;!-- ```{r acrossData} --&gt;
&lt;!-- # Applying transformations --&gt;
&lt;!-- transformed_tibble &lt;- my_tibble %&gt;% --&gt;
&lt;!--   mutate( --&gt;
&lt;!--     # Convert logical columns to numeric (TRUE to 1, FALSE to 0) --&gt;
&lt;!--     across(where(is.logical), as.numeric), --&gt;
&lt;!--     # Append "_modified" to the character values in column 'y' --&gt;
&lt;!--     across(where(is.character), ~ paste0(.x, "_modified")) --&gt;
&lt;!--   ) --&gt;

&lt;!-- transformed_tibble --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Note when you're using across() within mutate() or summarize(), `.x` represents the data from the current column being processed. It's a way to refer to each element of the column(s) you're applying the function to. --&gt;

&lt;!-- ### Summary --&gt;

&lt;!-- The dplyr functionality is powerful for wrangling data. With practice, you will learn to harness and layer the wide variety of functions and verbs in order to conduct numerous operations. My advice is that you start slow and gradually add on more complex combinations. --&gt;

&lt;!-- Also, this notebook has covered just a subset of the *types* of functions/verbs - those that operate on single rows and columns or groups of rows and columns. As you will see in the documentation, there are other functions/verbs that operate on whole data frames or that operate at vector level. We will touch on these later when we discuss data merging (or joining), which refers to combining two datasets with overlapping observations. --&gt;

&lt;!-- Finally, here is a good [reference](https://dplyr.tidyverse.org/articles/base.html) for comparing dplyr functions to their base R equivalents.## Introduction to the Tidyverse --&gt;

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create();
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
